{
  "posts": [
    {
      "id": 1,
      "createdAt": "2022-07-22T05:43:35Z",
      "author": "Swaubhik Chakraborty",
      "content": "<h1>Introduction</h1><p>Markdown and Mdx parsing is supported via <code>unified</code>, and other remark and rehype packages. <code>next-mdx-remote</code> allows us to parse <code>.mdx</code> and <code>.md</code> files in a more flexible manner without touching webpack.</p><p>GitHub flavored markdown is used. <code>mdx-prism</code> provides syntax highlighting capabilities for code blocks. Here's a demo of how everything looks.</p><p>The following markdown cheatsheet is adapted from: <a href='https://guides.github.com/features/mastering-markdown/' rel='noopener noreferrer' target='_blank'>https://guides.github.com/features/mastering-markdown/</a></p><h1>What is Markdown?</h1><p>Markdown is a way to style text on the web. You control the display of the document; formatting words as bold or italic, adding images, and creating lists are just a few of the things we can do with Markdown. Mostly, Markdown is just regular text with a few non-alphabetic characters thrown in, like <code>#</code> or <code>*</code>.</p><h1>Syntax guide</h1><p>Here‚Äôs an overview of Markdown syntax that you can use anywhere on GitHub.com or in your own text files.</p><p><br></p><h2>Headers</h2><pre class='ql-syntax' spellcheck='false'># This is a h1 tag## This is a h2 tag#### This is a h4 tag</pre><h1>This is a h1 tag</h1><h2>This is a h2 tag</h2><h4>This is a h4 tag</h4><h2>Emphasis</h2><pre class='ql-syntax' spellcheck='false'>_This text will be italic_**This text will be bold**_You **can** combine them_</pre><p><em>This text will be italic</em></p><p><strong>This text will be bold</strong></p><p><em>You </em><strong><em>can</em></strong><em> combine them</em></p><p><br></p><h2>Lists</h2><h3>Unordered</h3><pre class='ql-syntax' spellcheck='false'>- Item 1- Item 2 - Item 2a - Item 2b</pre><ul><li>Item 1</li><li>Item 2</li><li class='ql-indent-1'>Item 2a</li><li class='ql-indent-1'>Item 2b</li></ul><h3>Ordered</h3><pre class='ql-syntax' spellcheck='false'>1. Item 11. Item 21. Item 3 1. Item 3a 1. Item 3b</pre><ol><li>Item 1</li><li>Item 2</li><li>Item 3</li><li class='ql-indent-1'>Item 3a</li><li class='ql-indent-1'>Item 3b</li></ol><h2>Images</h2><pre class='ql-syntax' spellcheck='false'>![GitHub Logo](https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png)Format: ![Alt Text](url)</pre><p><img src='https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png' alt='GitHub Logo'></p><p><br></p><h2>Links</h2><pre class='ql-syntax' spellcheck='false'>http://github.com - automatic![GitHub](http://github.com)</pre><p><a href='http://github.com' rel='noopener noreferrer' target='_blank'>http://github.com</a> - automatic! <a href='http://github.com' rel='noopener noreferrer' target='_blank'>GitHub</a></p><p><br></p><h2>Blockquotes</h2><pre class='ql-syntax' spellcheck='false'>As Kanye West said:&gt; We're living the future so&gt; the present is our past.</pre><p>As Kanye West said:</p><p><br></p><blockquote>We're living the future so the present is our past.</blockquote><h2>Inline code</h2><pre class='ql-syntax' spellcheck='false'>I think you should use an`&lt;addr&gt;` element here instead.</pre><p>I think you should use an <code>&lt;addr&gt;</code> element here instead.</p><p><br></p><h2>Syntax highlighting</h2><p>Here‚Äôs an example of how you can use syntax highlighting with <a href='https://help.github.com/articles/basic-writing-and-formatting-syntax/' rel='noopener noreferrer' target='_blank'>GitHub Flavored Markdown</a>:</p><p><br></p><pre class='ql-syntax' spellcheck='false'>```js:fancyAlert.jsfunction fancyAlert(arg){if (arg){$.facebox({div: '#foo'})}}```</pre><p>And here's how it looks - nicely colored with styled code titles!</p><p>fancyAlert.js</p><p><br></p><pre class='ql-syntax' spellcheck='false'>function fancyAlert(arg){if (arg){$.facebox({div: '#foo'})}}</pre><h2>Footnotes</h2><pre class='ql-syntax' spellcheck='false'>Here is a simple footnote[^1]. With some additional text after it.[^1]: My reference.</pre><p>Here is a simple footnote<a href='https://tailwind-nextjs-starter-blog.vercel.app/blog/github-markdown-guide#user-content-fn-1' rel='noopener noreferrer' target='_blank'><sup>1</sup></a>. With some additional text after it.</p><p><br></p><h2>Task Lists</h2><pre class='ql-syntax' spellcheck='false'>- [x] list syntax required (any unordered or ordered list supported)- [x] this is a complete item- [] this is an incomplete item</pre><ul><li><br></li></ul><p>list syntax required (any unordered or ordered list supported)</p><p><br></p><p>this is a complete item</p><p><br></p><p><br></p><ul><li>this is an incomplete item</li></ul><h2>Tables</h2><p>You can create tables by assembling a list of words and dividing them with hyphens <code>-</code> (for the first row), and then separating each column with a pipe <code>|</code>:</p><p><br></p><p><br></p><pre class='ql-syntax' spellcheck='false'>| First Header | Second Header || --------------------------- | ---------------------------- || Content from cell 1 | Content from cell 2 || Content in the first column | Content in the second column |</pre><p>First HeaderSecond HeaderContent from cell 1Content from cell 2Content in the first columnContent in the second column</p><p><br></p><h2>Strikethrough</h2><p>Any word wrapped with two tildes (like <code>~~this~~</code>) will appear crossed out.</p>",
      "title": "Markdown Guide üìù",
      "excerpt": "Markdown and Mdx parsing is supported via unified, and other remark and rehype packages. next-mdx-remote allows us to parse .mdx and .md files in a more flexible manner without touching webpack."
    },
    {
      "id": 2,
      "createdAt": "2022-07-23T08:45:32Z",
      "author": "Swaubhik",
      "content": "<h2>Installation <a href='https://pinia.vuejs.org/getting-started.html#installation' rel='noopener noreferrer' target='_blank'>#</a></h2><p>Install <code>pinia</code> with your favorite package manager:</p><pre class='ql-syntax' spellcheck='false'>yarn add pinia# or with npmnpm install pinia</pre><p>TIP</p><p>If your app is using Vue 2, you also need to install the composition api: <code>@vue/composition-api</code>. If you are using Nuxt, you should follow <a href='https://pinia.vuejs.org/ssr/nuxt.html' rel='noopener noreferrer' target='_blank'>these instructions</a>.</p><p>If you are using the Vue CLI, you can instead give this <a href='https://github.com/wobsoriano/vue-cli-plugin-pinia' rel='noopener noreferrer' target='_blank'><strong>unofficial plugin</strong></a> a try.</p><p>Create a pinia instance (the root store) and pass it to the app as a plugin:</p><pre class='ql-syntax' spellcheck='false'>import{createApp}from 'vue'import{createPinia}from 'pinia'import App from './App.vue'const pinia=createPinia()const app=createApp(App)app.use(pinia)app.mount('#app')</pre><p>If you are using Vue 2, you also need to install a plugin and inject the created <code>pinia</code> at the root of the app:</p><pre class='ql-syntax' spellcheck='false'>import{createPinia, PiniaVuePlugin}from 'pinia'Vue.use(PiniaVuePlugin)const pinia=createPinia()new Vue({el: '#app', // other options... // ... // note the same `pinia` instance can be used across multiple Vue apps on // the same page pinia,})</pre><p>This will also add devtools support. In Vue 3, some features like time traveling and editing are still not supported because vue-devtools doesn't expose the necessary APIs yet but the devtools have way more features and the developer experience as a whole is far superior. In Vue 2, Pinia uses the existing interface for Vuex (and can therefore not be used alongside it).</p><h2>What is a Store? <a href='https://pinia.vuejs.org/getting-started.html#what-is-a-store' rel='noopener noreferrer' target='_blank'>#</a></h2><p>A Store (like Pinia) is an entity holding state and business logic that isn't bound to your Component tree. In other words, <strong>it hosts global state</strong>. It's a bit like a component that is always there and that everybody can read off and write to. It has <strong>three concepts</strong>, the <a href='https://pinia.vuejs.org/core-concepts/state.html' rel='noopener noreferrer' target='_blank'>state</a>, <a href='https://pinia.vuejs.org/core-concepts/getters.html' rel='noopener noreferrer' target='_blank'>getters</a> and <a href='https://pinia.vuejs.org/core-concepts/actions.html' rel='noopener noreferrer' target='_blank'>actions</a> and it's safe to assume these concepts are the equivalent of <code>data</code>, <code>computed</code> and <code>methods</code> in components.</p><h2>When should I use a Store <a href='https://pinia.vuejs.org/getting-started.html#when-should-i-use-a-store' rel='noopener noreferrer' target='_blank'>#</a></h2><p>A store should contain data that can be accessed throughout your application. This includes data that is used in many places, e.g. User information that is displayed in the navbar, as well as data that needs to be preserved through pages, e.g. a very complicated multi-step form.</p><p>On the other hand, you should avoid including in the store local data that could be hosted in a component instead, e.g. the visibility of an element local to a page.</p><p>Not all applications need access to a global state, but if yours need one, Pinia will make your life easier</p>",
      "title": "Getting started with Pinia üçç",
      "excerpt": "Pinia is a store library for Vue, it allows you to share a state across components/pages. If you are familiar with the Composition API, you might be thinking you can already share a global state with a simple export const state = reactive({}). This is true for single page applications but exposes your application to security vulnerabilities if it is server side rendered. "
    },

    {
      "id": 3,
      "createdAt": "2022-07-24T02:45:36.926Z",
      "title": "Introduction to VueJS 3",
      "author": "Swaubhik Chakraborty",
      "content": "<h2>What is Vue?</h2><h2><a href=\"https://vuejs.org/guide/introduction.html#what-is-vue\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">#</a></h2><p>Vue (pronounced /vjuÀê/, like&nbsp;view) is a JavaScript framework for building user interfaces. It builds on top of standard HTML, CSS and JavaScript, and provides a declarative and component-based programming model that helps you efficiently develop user interfaces, be it simple or complex.</p><p>Here is a minimal example:</p><pre class=\"ql-syntax\" spellcheck=\"false\">import { createApp } from 'vue'\n\ncreateApp({\n  data() {\n    return {\n      count: 0\n    }\n  }\n}).mount('#app')\n&lt;div id=\"app\"&gt;\n  &lt;button @click=\"count++\"&gt;\n    Count is: {{ count }}\n  &lt;/button&gt;\n&lt;/div&gt;\n</pre><p>Result</p><p>Count is: 0</p><p>The above example demonstrates the two core features of Vue:</p><ul><li>Declarative Rendering: Vue extends standard HTML with a template syntax that allows us to declaratively describe HTML output based on JavaScript state.</li><li><br></li><li>Reactivity: Vue automatically tracks JavaScript state changes and efficiently updates the DOM when changes happen.</li></ul><p>You may already have questions - don't worry. We will cover every little detail in the rest of the documentation. For now, please read along so you can have a high-level understanding of what Vue offers.</p><p>Prerequisites</p><p>The rest of the documentation assumes basic familiarity with HTML, CSS and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics and then come back! You can check your knowledge level with&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">this JavaScript overview</a>. Prior experience with other frameworks helps, but is not required.</p><h2>The Progressive Framework</h2><h2><a href=\"https://vuejs.org/guide/introduction.html#the-progressive-framework\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">#</a></h2><p>Vue is a framework and ecosystem that covers most of the common features needed in frontend development. But the web is extremely diverse - the things we build on the web may vary drastically in form and scale. With that in mind, Vue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways:</p><ul><li>Enhancing static HTML without a build step</li><li>Embedding as Web Components on any page</li><li>Single-Page Application (SPA)</li><li>Fullstack / Server-Side Rendering (SSR)</li><li>Jamstack / Static Site Generation (SSG)</li><li>Targeting desktop, mobile, WebGL, and even the terminal</li></ul><p>If you find these concepts intimidating, don't worry! The tutorial and guide only require basic HTML and JavaScript knowledge, and you should be able to follow along without being an expert in any of these.</p><p>If you are an experienced developer interested in how to best integrate Vue into your stack, or you are curious about what these terms mean, we discuss them in more details in&nbsp;<a href=\"https://vuejs.org/guide/extras/ways-of-using-vue.html\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">Ways of Using Vue</a>.</p><p>Despite the flexibility, the core knowledge about how Vue works is shared across all these use cases. Even if you are just a beginner now, the knowledge gained along the way will stay useful as you grow to tackle more ambitious goals in the future. If you are a veteran, you can pick the optimal way to leverage Vue based on the problems you are trying to solve, while retaining the same productivity. This is why we call Vue \"The Progressive Framework\": it's a framework that can grow with you and adapt to your needs.</p><p><br></p><h2>Single-File Components</h2><h2><a href=\"https://vuejs.org/guide/introduction.html#single-file-components\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">#</a></h2><p>In most build-tool-enabled Vue projects, we author Vue components using an HTML-like file format called&nbsp;Single-File Component&nbsp;(also known as&nbsp;<code style=\"color: var(--vt-c-text-code); background-color: var(--vt-c-bg-mute);\">*.vue</code>&nbsp;files, abbreviated as&nbsp;SFC). A Vue SFC, as the name suggests, encapsulates the component's logic (JavaScript), template (HTML), and styles (CSS) in a single file. Here's the previous example, written in SFC format:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;script&gt;\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;button @click=\"count++\"&gt;Count is: {{ count }}&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\nbutton {\n  font-weight: bold;\n}\n&lt;/style&gt;\n</pre><p>SFC is a defining feature of Vue, and is the recommended way to author Vue components&nbsp;if&nbsp;your use case warrants a build setup. You can learn more about the&nbsp;<a href=\"https://vuejs.org/guide/scaling-up/sfc.html\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">how and why of SFC</a>&nbsp;in its dedicated section - but for now, just know that Vue will handle all the build tools setup for you.</p><p><br></p><h2>API Styles</h2><h2><a href=\"https://vuejs.org/guide/introduction.html#api-styles\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">#</a></h2><p>Vue components can be authored in two different API styles:&nbsp;Options API&nbsp;and&nbsp;Composition API.</p><p><br></p><h3>Options API</h3><h3><a href=\"https://vuejs.org/guide/introduction.html#options-api\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">#</a></h3><p>With Options API, we define a component's logic using an object of options such as&nbsp;<code style=\"color: var(--vt-c-text-code); background-color: var(--vt-c-bg-mute);\">data</code>,&nbsp;<code style=\"color: var(--vt-c-text-code); background-color: var(--vt-c-bg-mute);\">methods</code>, and&nbsp;<code style=\"color: var(--vt-c-text-code); background-color: var(--vt-c-bg-mute);\">mounted</code>. Properties defined by options are exposed on&nbsp;<code style=\"color: var(--vt-c-text-code); background-color: var(--vt-c-bg-mute);\">this</code>&nbsp;inside functions, which points to the component instance:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;script&gt;\nexport default {\n  // Properties returned from data() become reactive state\n  // and will be exposed on `this`.\n  data() {\n    return {\n      count: 0\n    }\n  },\n\n  // Methods are functions that mutate state and trigger updates.\n  // They can be bound as event listeners in templates.\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n\n  // Lifecycle hooks are called at different stages\n  // of a component's lifecycle.\n  // This function will be called when the component is mounted.\n  mounted() {\n    console.log(`The initial count is ${this.count}.`)\n  }\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;button @click=\"increment\"&gt;Count is: {{ count }}&lt;/button&gt;\n&lt;/template&gt;\n</pre><p><a href=\"https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gcmVhY3RpdmUgc3RhdGVcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQ6IDBcbiAgICB9XG4gIH0sXG5cbiAgLy8gZnVuY3Rpb25zIHRoYXQgbXV0YXRlIHN0YXRlIGFuZCB0cmlnZ2VyIHVwZGF0ZXNcbiAgbWV0aG9kczoge1xuICAgIGluY3JlbWVudCgpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH1cbiAgfSxcblxuICAvLyBsaWZlY3ljbGUgaG9va3NcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zb2xlLmxvZyhgVGhlIGluaXRpYWwgY291bnQgaXMgJHt0aGlzLmNvdW50fS5gKVxuICB9XG59XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImluY3JlbWVudFwiPkNvdW50IGlzOiB7eyBjb3VudCB9fTwvYnV0dG9uPlxuPC90ZW1wbGF0ZT4ifQ==\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">Try it in the Playground</a></p><p><br></p><h3>Composition API</h3><h3><a href=\"https://vuejs.org/guide/introduction.html#composition-api\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">#</a></h3><p>With Composition API, we define a component's logic using imported API functions. In SFCs, Composition API is typically used with&nbsp;<code style=\"color: var(--vt-c-brand-dark); background-color: var(--vt-c-bg-mute);\"><a href=\"https://vuejs.org/api/sfc-script-setup.html\" rel=\"noopener noreferrer\" target=\"_blank\">&lt;script setup&gt;</a></code>. The&nbsp;<code style=\"color: var(--vt-c-text-code); background-color: var(--vt-c-bg-mute);\">setup</code>&nbsp;attribute is a hint that makes Vue perform compile-time transforms that allow us to use Composition API with less boilerplate. For example, imports and top-level variables / functions declared in&nbsp;<code style=\"color: var(--vt-c-text-code); background-color: var(--vt-c-bg-mute);\">&lt;script setup&gt;</code>&nbsp;are directly usable in the template.</p><p>Here is the same component, with the exact same template, but using Composition API and&nbsp;<code style=\"color: var(--vt-c-text-code); background-color: var(--vt-c-bg-mute);\">&lt;script setup&gt;</code>&nbsp;instead:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;script setup&gt;\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\n  count.value++\n}\n\n// lifecycle hooks\nonMounted(() =&gt; {\n  console.log(`The initial count is ${count.value}.`)\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;button @click=\"increment\"&gt;Count is: {{ count }}&lt;/button&gt;\n&lt;/template&gt;\n</pre><p><a href=\"https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiwgb25Nb3VudGVkIH0gZnJvbSAndnVlJ1xuXG4vLyByZWFjdGl2ZSBzdGF0ZVxuY29uc3QgY291bnQgPSByZWYoMClcblxuLy8gZnVuY3Rpb25zIHRoYXQgbXV0YXRlIHN0YXRlIGFuZCB0cmlnZ2VyIHVwZGF0ZXNcbmZ1bmN0aW9uIGluY3JlbWVudCgpIHtcbiAgY291bnQudmFsdWUrK1xufVxuXG4vLyBsaWZlY3ljbGUgaG9va3Ncbm9uTW91bnRlZCgoKSA9PiB7XG4gIGNvbnNvbGUubG9nKGBUaGUgaW5pdGlhbCBjb3VudCBpcyAke2NvdW50LnZhbHVlfS5gKVxufSlcbjwvc2NyaXB0PlxuXG48dGVtcGxhdGU+XG4gIDxidXR0b24gQGNsaWNrPVwiaW5jcmVtZW50XCI+Q291bnQgaXM6IHt7IGNvdW50IH19PC9idXR0b24+XG48L3RlbXBsYXRlPiJ9\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">Try it in the Playground</a></p><p><br></p><h3>Which to Choose?</h3><h3><a href=\"https://vuejs.org/guide/introduction.html#which-to-choose\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">#</a></h3><p>Both API styles are fully capable of covering common use cases. They are different interfaces powered by the exact same underlying system. In fact, the Options API is implemented on top of the Composition API! The fundamental concepts and knowledge about Vue are shared across the two styles.</p><p>The Options API is centered around the concept of a \"component instance\" (<code style=\"color: var(--vt-c-text-code); background-color: var(--vt-c-bg-mute);\">this</code>&nbsp;as seen in the example), which typically aligns better with a class-based mental model for users coming from OOP language backgrounds. It is also more beginner-friendly by abstracting away the reactivity details and enforcing code organization via option groups.</p><p>The Composition API is centered around declaring reactive state variables directly in a function scope, and composing state from multiple functions together to handle complexity. It is more free-form, and requires understanding of how reactivity works in Vue to be used effectively. In return, its flexibility enables more powerful patterns for organizing and reusing logic.</p><p>You can learn more about the comparison between the two styles and the potential benefits of Composition API in the&nbsp;<a href=\"https://vuejs.org/guide/extras/composition-api-faq.html\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: var(--vt-c-brand); background-color: transparent;\">Composition API FAQ</a>.</p><p>If you are new to Vue, here's our general recommendation:</p><ul><li>For learning purposes, go with the style that looks easier to understand to you. Again, most of the core concepts are shared between the two styles. You can always pick up the other style later.</li><li><br></li><li>For production use:</li><li>Go with Options API if you are not using build tools, or plan to use Vue primarily in low-complexity scenarios, e.g. progressive enhancement.</li><li class=\"ql-indent-1\"><br></li><li class=\"ql-indent-1\">Go with Composition API + Single-File Components if you plan to build full applications with Vue.</li></ul><p>You don't have to commit to only one style during the learning phase. The rest of the documentation will provide code samples in both styles where applicable, and you can toggle between them at any time using the&nbsp;API Preference switches&nbsp;at the top of the left sidebar.</p>",
      "excerpt": "Vue (pronounced /vjuÀê/, like view) is a JavaScript framework for building user interfaces. It builds on top of standard HTML, CSS and JavaScript, and provides a declarative and component-based programming model that helps you efficiently develop user interfaces, be it simple or complex."
    }
  ],
  "highlights": []
}
